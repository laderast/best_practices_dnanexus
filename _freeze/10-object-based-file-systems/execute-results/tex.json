{
  "hash": "6ca7887252f0610aec4272a719f45a2b",
  "result": {
    "markdown": "# Object Based File Systems\n\nProject storage on the DNAnexus platform is *object-based*. This kind of filesystem is probably very different from other file systems you've experienced.\n\nThe goal of this chapter is to show how the filesystem is different from your previous experiences, and to highlight ways to work successfully on the platform given this filesystem. Specifically you will be able to:\n\n1. **Compare** and **contrast** differences between object-based file systems and POSIX filesystems\n1. **Explain** the role of metadata and folders in organizing data and outputs\n1. **Set up** a project for reproducible analysis\n1. **Tag** and **utilize** tags for selecting files and separating output from multiple jobs.\n\n\n## Terminology\n\n- **POSIX** - The filesystem that linux is based on. POSIX filesystems have *paths* and *files*.\n- **Data** - The actual file contents. For example, for a CSV file, the actual header and rows correspond to the data.\n- **Metadata** - information that is not part of the data, but is associated with the data. For our CSV file, some examples of metadata are the *file permissions* (who can access the file), the *creator*, and the *creation date*. \n- **Object** - A contiguous set of memory that contains both the *data* and *metadata*. Has a unique identifier. \n- **Unique Identifier** - the actual \"address\" for accessing the file. Unique to the file object when it is created. Does not change for the entire lifecycle of an object.\n- **Database Engine** - software that allows for rapid searching and retrieving objects. \n\n## Review: POSIX Filesystems\n\nYou may be familar with *directory based* filesystems as a way to organize your data. The main way to find/refer to a file is through its *path*. What does this mean?\n\nFor example, if my file is called `chr1.vcf.gz` and it is located in the directory `/Geno_Data`, we'd refer to it using the *full path*:\n\n```\n/Geno_Data/chr1.vcf.gz\n```\n\nPaths are the main way we organize files for directory based systems. This information is external to a file. Most importantly, we use directories to organize and group files logically. For example, we might have our R script and the data it analyzes in the same directory. \n\nFor a file in a POSIX-based filesystem, **the path needs to be unique.** If they are not, there are rules for whether to replace that file with a new one, or to save both versions. For example, we can't have two files named:\n\n```\n/Geno_Data/chr1.vcf.gz\n```\nIn the same folder. That violates our ability to find a file in the system. \n\n<https://grimoire.carcano.ch/blog/posix-compliant-filesystems/>                          \n<https://www.kernel.org/doc/html/latest/filesystems/fuse.html>\n\n## Object Based Filesystems are different\n\nIn contrast, object-based filesystems do not organize data like a folder based system. Each file object (such as a csv file, or a BAM file) has a unique identifier that identifies the data object. This unique identifier (like `file-aagejFHEJSEI`) serves as the main way to locate the data object, rather than the path. \n\nHowever, file objects also have metadata that can be attached to them. This metadata can be:\n\n|Metadata Type|Example|Code Example|\n|-------|----------------------|---|\n|ID|`project-XXXXX:file-YYYYYY`|`dx mv file-YYYY raw_data/`| \n|name|`chr1.tar.gz`|`dx find data --name chr1.tar.gz`\n|Path|`/raw_data/chr1.tar.gz`|\n|Creation Date||\n|Tags|`report`, `run1`|\n|Properties|`eid = 1153xxx`|\n\nOn the DNAnexus platform, both the *filename* and its path are considered **metadata**. This metadata is part of the object, along with the data portion of the object. \n\nImportantly, *folders are not considered objects on the platform* - folders only exist within the metadata for the file objects. \n\nThe other issue is that the metadata for an object has no requirements to be unique. Which means you can have duplicates with the same file name in the same folder. \n\nI know, this can be very distressing for most people. You can have two objects with the same file name, but they are considered distinct objects because they have unique identifiers. \n\n<https://www.ibm.com/cloud/blog/object-vs-file-vs-block-storage>\n\n## Comparing POSIX and Object Based File Systems\n\n|Concept|POSIX File System|Object-Based System|\n|-------|-----------------|-------------------|\n|File ID|Represented by Full Path|Represented by Object ID|\n|Storage|Data with limited metadata|Metadata+Data|\n|Path/Filename|Must be Unique|Can be duplicated|\n|Metadata|Limited|Rich, can be freely modified|\n\n\n## Tracing the journey of a file object onto the platform\n\nWhen a file uploaded, file objects go through three stages before they are available. These stages are:\n\n1. **Open** - Files are still being transferred via `dx upload` or the Upload Agent `ua`.\n1. **Closing** - File objects stay in this state for no longer than 8-10 seconds.\n1. **Closed** - Files are now available to be utilized on the platform, either with an app, workflow, or downloaded.\n\n```\n% dx describe file-FpQKQpQ0Fgk3gQZz3gPXQj7x\nResult 1:\nID                    file-FpQKQpQ0Fgk3gQZz3gPXQj7x\nClass                 file\nProject               project-GJ496B00FZfxPV5VG36FybvY\nFolder                /data\nName                  NA12878.bai\nState                 closed\nVisibility            visible\nTypes                 -\nProperties            -\nTags                  -\nOutgoing links        -\nCreated               Wed Apr 22 17:59:22 2020\nCreated by            emiai\n via the job          job-FpQGX780FgkG4bGz86zZk04V\nLast modified         Thu Oct 13 15:38:04 2022\nMedia type            application/octet-stream\narchivalState         \"live\"\nSize                  2.09 MB, sponsored by DNAnexus\ncloudAccount          \"cloudaccount-dnanexus\"\n```\n\n## Copying Files from One Project to Another\n\nCopying has an important definition on the platform: *it means copying a file from one project to another project.* It doesn't refer to duplicating a file within a project.\n\nWhen we copy a file from one project to another, a new physical copy is not made. The reference to the original file is copied. The data is identical and points to the same location on the platform, and the metadata is copied to the new project.\n\nThis is quite nice in that you are not doubly charged for storage on the platform. You do have the ability to [clone files](https://documentation.dnanexus.com/developer/api/data-containers/cloning#specification) into a different project - that way a physical copy of the data is created.  \n\nOnce the metadata is copied into the new project, there is no syncing of the metadata between the two projects. User 1 is free to modify the metadata in Project A and changes are not made to the metadata in Project B. \n\n### Advantages of Object Based Filesystems\n\nThe DNAnexus platform is only one example of an object-based filesystem. Other examples include Amazon S3 (Simple Storage Service), which is one of the biggest examples. Why does the world run on object based filesystems? There are a lot of advantages. \n\n- **Highly scalable.** This is the main reason given for using an object-based system. Given that unique identifier, the data part of the object can be very large.\n- **Fast Retrieval.** Object-based filesystems let us work with arbitrarily large file sizes, and we can actually stream files to and from workers.\n- **Improved search speed.** You can attach various database engines to a set of objects and rapidly search through them. An example of such an engine is Snowflake.\n- **File operations are simplified.** Compared to POSIX filesystems, there are only a few [object filesystem commands](https://www.enterprisestorageforum.com/management/object-storage-vs-posix-storage-something-in-the-middle-please/): PUT, GET, DELETE, POST, HEAD.\n\n### Disadvantages of Object Based Filesystems\n\nComing from folder based filesystems, it can be a bit of a mind-bender getting used to object-based filesystems. Some of the disadvantages of Object Based Filesystems include:\n\n- **Objects are immutable**. You can't edit an object in place. If you modify a file on a worker, you can't overwrite the original file object. A new file object must be created. \n- **You have to be careful when generating outputs**. You can end up with two different objects with the same filename, and it can be some work to disambiguate these objects.\n- **It's confusing.** You can actually have two files with the same filename in the same folder, because it is part of the changeable metadaa. Disambiguating these two files without using file-ids can be difficult. There are rules that govern this.\n- **Metadata is much more important with file management.** Seriously, use tags for everything, including jobs and files. It will make working with multiple files much easier. And if you are on UKB RAP, leverage the file property metadata (`eid` and `field_id`) to help you select the files you want to process.\n\n\n## Always add project IDs to your File IDs\n\nIn Bash for Bioinformatics, we already discovered one way of working with files on the platform: `dx find data` (@sec-dx-find). This is our main tool for selecting files with metadata.\n\nWhen we work with files outside of our current project, we might reference it by a file-id. Using file IDs by themselves are a global operation and we need to be careful when we use this!\n\nWhy is this so? There is a search tree when we use a file ID that is not in our project and without a project context. [The search over metadata](https://documentation.dnanexus.com/user/projects/path-resolution) is looking for a file object based on just file ID. \n\n1. Look for the file in the current project\n2. Look at all files across all other projects\n\nIf you want to use the platform effectively, you want to avoid 2. at all costs, especially when working with a lot of files. The metadata server will take much longer to find your files.\n\nThe lesson here is when using file-ids, it is safer to put the project-id in front of your file id such as below:\n\n```\nproject-XXXXX:file-YYYYYYYYY\n```\n\n\n## Batch Tagging\n\nRemember, we can leverage `xargs` for tagging multiple files:\n\n::: {.cell execution_count=1}\n``` {.bash .cell-code}\ndx find data --name \"*bam\" --brief | xargs -I% sh -c \"dx tag % 'bam'\"\n```\n:::\n\n\nAfter we do this, we can check whether our operation was successful. We can run:\n\n::: {.cell execution_count=2}\n``` {.bash .cell-code}\ndx find data --tag bam --brief\n```\n:::\n\n\nAnd here is our response:\n\n```\nproject-GJ496B00FZfxPV5VG36FybvY:file-BZ9YGzj0x05b66kqQv51011q\nproject-GJ496B00FZfxPV5VG36FybvY:file-BZ9YGpj0x05xKxZ42QPqZkJY\nproject-GJ496B00FZfxPV5VG36FybvY:file-BQbXVY0093Jk1KVY1J082y7v\nproject-GJ496B00FZfxPV5VG36FybvY:file-FpQKQk00FgkGV3Vb3jJ8xqGV\n\n```\n\nUsing the `dx find data/xargs/dx tag` combination with various input parameters to `dx find data` such as `--name`, `--created-before`, `--created-after`, `--class`, will help us to batch tag files and other objects on the platform.\n\n## Use Case: Use tags for archiving\n\nLet's do something concrete and useful in our project: tag files we no longer need for archiving.\n\nSay there are files we want to archive. We can use `dx tag` or the DNAnexus UI to tag these files with a specific tag, such as `to_archive`. This can be done by users.\n\nAn administrator can then run a monthly job that archives the files with these tags using `dx api <project-id> archive --tag to_archive`.\n\n:::{.callout-note}\n## What about dxFUSE?\n\nYou might ask about the role of dxFUSE with the Object Based Filesystem.\n\nIn short, dxFUSE makes the Object Based Filesystem of DNAnexus act like a POSIX filesystem. Specifically, if there are multiple objects with the same name within a folder, it provides a way to specify these objects using file paths. \n:::\n\n:::{.callout-note}\n## Par-what-now?\n\nYou may have heard of *Parquet* files and wondered how they relate to file objects on the platform. They are a way to store data in a format called *columnar* storage.\n\nIt turns out it is faster for retrieval to store data not by *rows*, but by *columns*. This is really helpful because the data is sorted by *data* type and it's easier to traverse for this reason. \n\nThere are a number of *database engines* that are fast at searching and traversing these types of files. Some examples are Snowflake and Apache Arrow. \n\nOn the DNAnexus platform, certain data objects (called Datasets) are actually stored in Parquet format, for rapid searching and querying using Apache Spark.\n:::\n\n",
    "supporting": [
      "10-object-based-file-systems_files/figure-pdf"
    ],
    "filters": []
  }
}